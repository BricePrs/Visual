#version 430 core

layout(binding = 2, rgba32f) uniform image2D framebuffer;

uniform sampler2D envMap;
uniform sampler2D groundTexture;
uniform mat4 mat_inverse;
uniform mat4 persp_inverse;
uniform float lightIntensity;
uniform vec3 lightPosition;
uniform bool blinnPhong;
uniform bool fastGammaCorrection;
uniform bool transparent;
uniform float shininess;
uniform vec2 eta;
uniform vec4 ObjectColor;
uniform vec3 eta3dReal;
uniform vec3 eta3dImag;
uniform float radius;
uniform float groundDistance;
uniform bool enableEnvMap;
uniform float tileScale;
uniform bool resetAccumulation;
uniform bool sphereModel;
uniform bool checkBoard;
uniform int accumulationCount;
uniform float glassIndex;

#define MAX_RAY_BOUNCES     5
#define MAX_SCENE_BOUNDS    10.0
#define EPS                 0.000001

#define MIN_DISTANCE EPS
#define GROUND_VPTR -1

#define M_1_PI 0.31830988618

#define Ka 0.05
#define Kd 0.3

struct hitinfo_t {
/* Index of the first index of the triangle */
/* or: GROUND_VPTR */
    int hit_vptr;
/* Intersection distance, barycentric coordinates */
/* or: intersection distance, 0, texture coordinates (for the ground) */
    vec4 t;
};

struct BVHNode {
    vec4 min;
    vec4 max;
    int nbTriangles;
    int index;
};

layout (std430, binding = 1) buffer Vertices
{
    vec4 vertices[];
};

layout (std430, binding = 2) buffer Normals
{
    vec4 normals[];
};

layout (std430, binding = 3) buffer Colors
{
    vec4 colors[];
};

layout (std430, binding = 4) buffer Meshes
{
    int indices[];
};

layout (std430, binding = 5) buffer BVHNodes
{
    BVHNode nodes[];
};



// Noise func I found on the Internet

highp float noise(in vec2 xy, in float seed){
    return fract(seed*sin(dot(xy,seed*vec2(163.2442, 187.129))));
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint hash( uint x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}

// Compound versions of the hashing algorithm I whipped together.
uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }



// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float floatConstruct( uint m ) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32

    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0

    float  f = uintBitsToFloat( m );       // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}



// Pseudo-random value in half-open range [0:1].
float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }




// Check whether there is an intersection between the ray (origin, dir) and the bounding box (bbmin, bbmax),
// stores into tNear the nearest point of intersection on the ray.
bool intersectBoundingBox(vec4 origin, vec4 dir, vec4 bbmin, vec4 bbmax, out float tNear)
{
    // intersect with BB:
    vec4 sMin = (bbmin - origin) / dir;
    vec4 sMax = (bbmax - origin) / dir;

    vec4 tMin = min(sMin, sMax);
    vec4 tMax = max(sMin, sMax);

    tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);

    if (tNear < 0) tNear = 0; // starting point inside the BVH
    return tNear <= tFar;
}

bool intersectTriangle2(vec4 origin, vec4 dir, int ptr, out vec4 dist) {

    // vertices from data:
    vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    vec3 v0v1 = (v1 - v0).xyz;
    vec3 v0v2 = (v2 - v0).xyz;
    vec3 pvec = cross(dir.xyz, v0v2.xyz);
    float det = dot(v0v1, pvec);

    // if the determinant is negative, the triangle is 'back facing'
    //if (det < kEpsilon) return false;
    // ray and triangle are parallel if det is close to 0
    if (abs(det) < EPS) return false;
    float invDet = 1 / det;

    vec3 tvec = origin.xyz - v0.xyz;
    dist.y = dot(tvec, pvec) * invDet;
    if (dist.y < 0 || dist.y > 1) return false;

    vec3 qvec = cross(tvec, v0v1);
    dist.z = dot(dir.xyz, qvec) * invDet;
    if (dist.z < 0 || dist.y + dist.z > 1) return false;

    dist.w = 1.-dist.y-dist.z;

    dist.x = dot(v0v2, qvec) * invDet;
    return (dist.x > EPS);
}

// intersect ray (origin, dir) with triangle defined by ptr (number inside indexed face set)
// returns a boolean, plus the "t" of hitinfo structure (Intersection distance, barycentric coordinates)
bool intersectTriangle(vec4 origin, vec4 dir, int ptr, out vec4 dist)
{
    // vertices from data:
    vec4 v0 = vertices[indices[ptr]];
    vec4 v1 = vertices[indices[ptr + 1]];
    vec4 v2 = vertices[indices[ptr + 2]];

    vec3 e1 = (v1 - v0).xyz;
    vec3 e2 = (v2 - v0).xyz;

    vec3 p = cross(dir.xyz, e2);
    float det = dot(e1, p);
    if (abs(det) < EPS) return false;

    // We do early exit here: as soon as we can return false, we do.
    // In my tests, it is faster than computing all coordinates,
    // *then* checking validity with a single test. YMMV, feel free to test
    vec3 t = (origin - v0).xyz;
    dist.y = dot(t, p);
    if (dist.y < 0.0 || dist.y > det) return false;
    vec3 q = cross(t, e1);
    dist.z = dot(dir.xyz, q);
    if (dist.z < 0.0 || dist.z > det) return false;
    dist.w = det - dist.y - dist.z;
    if (dist.w < 0.0) return false;
    dist.x = dot(e2, q);
    dist /= det;
    return (dist.x > EPS);
}

bool intersectGround(vec4 origin, vec4 dir, out vec4 dist)
{
    if (abs(dir.y) < EPS)
    return false;
    float t = -(origin.y + groundDistance) / dir.y;

    if (t < MIN_DISTANCE)
    return false;

    vec4 point = origin + t * dir;
    point.y = -groundDistance;
    vec4 scaledPoint = point / radius ;
    vec2 texCoords = 0.5 * scaledPoint.xz + 0.5;

    dist = vec4(t, 0.0, texCoords);

    return true;
}

vec4 interpolateColor(hitinfo_t h)
{
    return pow(ObjectColor, vec4(2.2));
    if (colors.length() > 0) {
        vec4 c0 = colors[indices[h.hit_vptr]];
        vec4 c1 = colors[indices[h.hit_vptr + 1]];
        vec4 c2 = colors[indices[h.hit_vptr + 2]];
        return pow(h.t.w * c0 + h.t.y * c1 + h.t.z * c2, vec4(2.2));
    } else return pow(ObjectColor, vec4(2.2));
}

vec4 interpolateNormal(hitinfo_t h)
{
    if (h.hit_vptr == -1) { return vec4(0., 1., 0., 1.); }
    vec4 n0 = normals[indices[h.hit_vptr]];
    vec4 n1 = normals[indices[h.hit_vptr + 1]];
    vec4 n2 = normals[indices[h.hit_vptr + 2]];
    return normalize(h.t.w * n0 + h.t.y * n1 + h.t.z * n2);
}

// BVH-related functions:
bool isLeaf(BVHNode node)
{
    return node.nbTriangles != 0;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir, inout hitinfo_t h)
{
    bool hit = false;

    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle2(origin, dir, vptr, dist) && dist.x < h.t.x) {
            hit = true;
            h.hit_vptr = vptr;
            h.t = dist;
        }
    }

    return hit;
}

bool intersectBVHLeaf(BVHNode node, vec4 origin, vec4 dir)
{
    for (int i = 0; i < node.nbTriangles; ++i) {
        int vptr = 3 * (node.index + i);
        vec4 dist;
        if (intersectTriangle(origin, dir, vptr, dist))
        return true;
    }

    return false;
}

#define MAX_STACK_SIZE 64

#define push(stack, size, value) stack[size++] = value
#define pop(stack, size) stack[--size]

bool intersectBVH(vec4 origin, vec4 dir, inout hitinfo_t h)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
    return false;

    struct StackElement {
        int index;
        float t;
    } stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, StackElement(rootIndex, 0.0));

    bool hit = false;
    while (size != 0) {
        StackElement current = pop(stack, size);
        if (h.t.x < current.t)
        continue;

        BVHNode currentNode = nodes[current.index];
        if (isLeaf(currentNode)) {
            hit = intersectBVHLeaf(currentNode, origin, dir, h) || hit;
        } else {
            StackElement left = StackElement(current.index + 1, 0.0);
            BVHNode leftNode = nodes[left.index];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, left.t);

            StackElement right = StackElement(currentNode.index, 0.0);
            BVHNode rightNode = nodes[right.index];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, right.t);

            if (hitLeft && hitRight) {
                if (left.t < right.t) {
                    push(stack, size, right);
                    push(stack, size, left);
                } else {
                    push(stack, size, left);
                    push(stack, size, right);
                }
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }


    return hit;
}


bool intersectBVH(vec4 origin, vec4 dir)
{
    int rootIndex = 0;
    BVHNode rootNode = nodes[rootIndex];
    float tNear;

    if (!intersectBoundingBox(origin, dir, rootNode.min, rootNode.max, tNear))
    return false;

    int stack[MAX_STACK_SIZE];
    int size = 0;

    push(stack, size, rootIndex);

    while (size != 0) {
        int current = pop(stack, size);
        BVHNode currentNode = nodes[current];
        if (isLeaf(currentNode)) {
            if (intersectBVHLeaf(currentNode, origin, dir))
            return true;
        } else {
            int left = current + 1;
            BVHNode leftNode = nodes[left];
            bool hitLeft = intersectBoundingBox(origin, dir, leftNode.min, leftNode.max, tNear);

            int right = currentNode.index;
            BVHNode rightNode = nodes[right];
            bool hitRight = intersectBoundingBox(origin, dir, rightNode.min, rightNode.max, tNear);

            if (hitLeft && hitRight) {
                push(stack, size, right);
                push(stack, size, left);
            } else if (hitLeft) {
                push(stack, size, left);
            } else if (hitRight) {
                push(stack, size, right);
            }
        }
    }

    return false;
}
// End BVH-related functions


bool intersectSphere(vec4 origin, vec4 dir, inout hitinfo_t h) {
    // Sphere parameters (replace these with your actual sphere parameters)
    vec4 sphere_center = vec4(0.0, 0.0, 0.0, 1.0);
    float sphere_radius = 1.0;

    // Ray-sphere intersection algorithm
    vec4 oc = origin - sphere_center;
    float a = dot(dir, dir);
    float b = 2.0 * dot(oc, dir);
    float c = dot(oc, oc) - sphere_radius * sphere_radius;

    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        // No intersection
        return false;
    }

    // Compute the two possible intersection points
    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

    // Find the nearest intersection point in front of the ray
    float t = min(t1, t2);

    if (t < 0.0) {
        // Both intersections are behind the ray
        return false;
    }

    // Compute intersection point and update hitinfo
    h.hit_vptr = 0;
    h.t = vec4(t, vec4(0.));

    return true;
}

// Compute the first intersection along the ray (origin, dir).
// returns the nearest intersection in h
bool firstIntersection(vec4 origin, vec4 dir, out hitinfo_t h)
{
    h.t.x = radius * MAX_SCENE_BOUNDS;

    bool hit;
    if (sphereModel) {
        hit = intersectSphere(origin, dir, h);
    } else {
        hit = intersectBVH(origin, dir, h);
    }
    vec4 dist;
    if (intersectGround(origin, dir, dist) && dist.x < h.t.x) {
        hit = true;
        h.hit_vptr = GROUND_VPTR;
        h.t = dist;
    }

    return hit;
}

// checks whether there is any intersection along the ray (origin, dir)
// Does not compute the nearest intersection, ends the loop as soon as an intersection is found.
bool isIntersected(vec4 origin, vec4 dir)
{
    vec4 dist;
    return intersectGround(origin, dir, dist) || intersectBVH(origin, dir);
}

bool try_refract(vec3 I, vec3 N, float eta, out vec3 ref) {
    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
    if (k < 0.0) { return false; }
    ref = normalize(eta * I - (eta * dot(N, I) + sqrt(k)) * N);
    return true;
}

// Local illumination related functions.

float real_fresnel(in float cos_th, in float eta) {
    float eta_sq = eta*eta;
    float cos_th_sq = cos_th*cos_th;
    float c_sq = eta_sq - 1 + cos_th_sq;
    if (c_sq < 0.) {
        return 1.;
    }
    float c = sqrt(c_sq); // Positive ??

    float f_s = (cos_th-c)/(cos_th+c);
    f_s *= f_s;
    float f_p = (eta_sq*cos_th-c)/(eta_sq*cos_th+c);
    f_p *= f_p;

    return clamp((f_s+f_p)/2., EPS, 1.-EPS);
}

float complex_fresnel(in float cos_th, in vec2 eta) {
    vec2 eta_sq = vec2(eta.x*eta.x-eta.y*eta.y, 2.*eta.x*eta.y);
    float cos_th_sq = cos_th*cos_th;
    vec2 c_sq = vec2(eta_sq.x - 1 + cos_th*cos_th, eta_sq.y);
    vec2 polar_c_sq = vec2(length(c_sq), atan(c_sq));
    vec2 c = sqrt(polar_c_sq.x)*vec2(cos(polar_c_sq.y*.5), sin(polar_c_sq.y*.5));
    vec2 complex_f_s = vec2(
    cos_th_sq-c.x*c.x+c.y*c.y,
    -2.*(c.y*cos_th)
    ) / ((cos_th+c.x)*(cos_th+c.x)+(c.y*c.y));
    float f_s = complex_f_s.x*complex_f_s.x+complex_f_s.y*complex_f_s.y;

    vec2 complex_f_p = vec2(
    eta_sq.x*eta_sq.x*cos_th_sq-c.x*c.x+c.y*c.y-eta_sq.y*eta_sq.y*cos_th_sq,
    +2.*(c.x*eta_sq.y*cos_th - eta_sq.x*cos_th*c.y)
    ) / ((eta_sq.x*cos_th+c.x)*(eta_sq.x*cos_th+c.x)+(eta_sq.y*cos_th+c.y)*(eta_sq.y*cos_th+c.y));
    float f_p = complex_f_p.x*complex_f_p.x+complex_f_p.y*complex_f_p.y;

    return (f_s+f_p)/2.;
}

float fresnel(in float cos_th, in vec2 eta) {
    if (abs(eta.y) < 0.00001) {
        return real_fresnel(cos_th, eta.x);
    }
    return complex_fresnel(cos_th, eta);
}

float blinnPhongSpecular(in vec4 v, in vec4 n, in vec3 l, in vec2 eta) {
    vec3 halfVector = normalize(v.xyz+l);
    float cos_th = max(0., dot(halfVector, l));
    return fresnel(cos_th, eta)*pow(max(dot(halfVector, n.xyz), 0), shininess+0.00001);
}

float MicroFacetDist(float cos_th, float alpha) {
    float pi = 3.141593;
    float xhi = step(0., cos_th);
    float cos_th_sq = cos_th*cos_th;
    float tan_th_sq = 1./cos_th_sq-1.;
    float a = xhi/(pi*cos_th_sq*cos_th_sq);
    float b = alpha/(alpha*alpha+tan_th_sq);
    return a*b*b;
}

float GGXDist(float cos_th, float alpha) {
    float cos_th_sq = cos_th*cos_th;
    float tan_th_sq = 1./cos_th_sq-1.;
    return 1./(cos_th+sqrt(cos_th_sq+alpha*alpha*(1.-cos_th_sq)));
}

float cookTorranceSpecular(in vec4 v, in vec4 n, in vec3 l, in vec2 eta) {
    float alpha = mix(0.5, 0.001, sqrt(shininess*0.005));
    vec3 halfVector = normalize(v.xyz+l);
    float cos_th   = dot(halfVector, l.xyz);
    float cos_th_i = dot(v.xyz, n.xyz);
    float cos_th_o = dot(l.xyz, n.xyz);
    float cos_th_h = dot(halfVector, n.xyz);

    if ((cos_th_o < 0) || (cos_th_i < 0)) {
        return 0.;
    }

    return fresnel(cos_th, eta)*MicroFacetDist(cos_th_h, alpha)*GGXDist(cos_th_i, alpha)*GGXDist(cos_th_o, alpha);
}

vec4 directIllumination(vec4 color, vec4 p, vec4 n, vec4 v, vec3 l)
{
    // Goal: compute direct illumination at point p, from the light source at lightPosition.
    // color: local material color, RGBA
    // p: coordinates of intersection point, xyzw
    // n: normal at intersection point, xyzw
    // v: incoming viewing direction. Points towards the eye.
    // l: point -> light vector

    float lightDist = length(l);
    l /= lightDist;

    hitinfo_t hit;
    if (dot(n.xyz, l) < 0 || firstIntersection(p+0.001*n,  vec4(l, 0.), hit)) {
        if (lightDist-EPS > hit.t.x) {
            return vec4(Ka*color.xyz*lightIntensity, 1.0);
        }
    }

    float ambt = Ka;
    float diff = Kd*max(0., dot(n.xyz, l));
    vec3 spec;
    if (blinnPhong) {
        spec = vec3(blinnPhongSpecular(v, n, l, vec2(eta3dReal.x, eta3dImag.x)),
        blinnPhongSpecular(v, n, l, vec2(eta3dReal.y, eta3dImag.y)),
        blinnPhongSpecular(v, n, l, vec2(eta3dReal.z, eta3dImag.z)));
    } else {
        spec = vec3(cookTorranceSpecular(v, n, l, vec2(eta3dReal.x, eta3dImag.x)),
        cookTorranceSpecular(v, n, l, vec2(eta3dReal.y, eta3dImag.y)),
        cookTorranceSpecular(v, n, l, vec2(eta3dReal.z, eta3dImag.z)));
    }

    return vec4(((ambt+diff)*color.xyz+spec)*lightIntensity, 1.0);
}


const int MAX_TRACE = 8;
const int MAX_REFLECT = 7;

void getLocal(vec4 origin, vec4 dir, hitinfo_t h, out vec4 color, out vec4 p, out vec4 n)
{
    p = origin + h.t.x * dir;
    if (h.hit_vptr == GROUND_VPTR) {
        if (checkBoard) {
            color = vec4(clamp(float((int(p.x) + int(p.z)) % 2), 0., 1.));
        } else {
            color = texture(groundTexture, h.t.pq*tileScale);
        }
        p.y = -groundDistance;
        n = vec4(0.0, 1.0, 0.0, 0.0);
    } else {
        color = interpolateColor(h);
        if (sphereModel) {
            n = normalize(origin+h.t.x*dir);
        } else {
            n = interpolateNormal(h);
        }
    }
}


struct trace_state_t
{
    vec4 origin;        // start of ray
    vec4 dir;           // direction
    vec4 color;         // color after multiple bounces
    vec4 localColor;    // color of the material (after interpolation)
    hitinfo_t h;        // what the ray hits (triangle Id, u, v, lambda)
    vec4 hit;           // point the ray hits
    vec4 Ld;            // direction to light at destination
    vec4 N;             // normal at destination
};

vec4 trace(vec4 origin, vec4 dir)
{
    trace_state_t stack[MAX_TRACE + 1];
    bool fallback[MAX_TRACE + 1];
    int sp = 0;
    int reflectCount = 0;
    vec4 lastIntersection = origin;
    vec4 lastDirection = dir;
    stack[0].color = vec4(0.);
    vec4 skyColor = pow(vec4(1., 0.1, 0.2, 0.), vec4(2.2));

    if (enableEnvMap) {
        stack[0].color = texture(envMap, vec2(atan(dir.z, dir.x)*.5/3.1416, dir.y*.5+.5)); // Default to black if no intersection for the first ray
    } else {
        stack[0].color = skyColor;
    }

    if (fastGammaCorrection) {
        stack[0].color = min(pow(stack[0].color, vec4(2.2)), 1.);
    }

    bool hasHit = false;
    bool isInsideObject = false;
    int surface = 0;

    // Forward tracing
    for (; sp <= MAX_TRACE, reflectCount < MAX_REFLECT; ++sp) {
        hasHit = firstIntersection(lastIntersection, lastDirection, stack[sp].h);
        if (hasHit) {
            getLocal(lastIntersection, lastDirection, stack[sp].h, stack[sp].localColor, stack[sp].hit, stack[sp].N);
        } else {
            ++sp;
            stack[sp-1].color = vec4(0.);
            if (enableEnvMap) {
                stack[sp-1].color = texture(envMap, vec2(atan(lastDirection.z, lastDirection.x)*.5/3.1416, lastDirection.y*.5+.5));
            } else {
                stack[sp-1].color = skyColor;
            }
            if (fastGammaCorrection) {
                stack[sp-1].color = min(pow(stack[sp-1].color, vec4(2.2)), 1.);
            }
            break;
        }
        stack[sp].origin = lastIntersection;
        stack[sp].dir = lastDirection;

        float s = 1.;
        float n = glassIndex;
        if (isInsideObject) {
            n = 1./n;
            s = -1.;
        }
        float cos_th = max(0., s*dot(stack[sp].N.xyz, -stack[sp].dir.xyz));
        float rd = random(vec4(lastDirection.xyz, float(accumulationCount*0.167)));

        vec3 normal = s*stack[sp].N.xyz;
        vec3 refractedRay;
        if (transparent && stack[sp].h.hit_vptr != -1) {
            stack[sp].localColor = vec4(0.);
        }
        if (transparent && (stack[sp].h.hit_vptr != -1) && try_refract(lastDirection.xyz, normal, 1./n, refractedRay) && rd >= real_fresnel(cos_th, n)) {
            lastDirection.xyz = refractedRay;
            isInsideObject = !isInsideObject;
            ++surface;
        } else {
            lastDirection.xyz = reflect(lastDirection.xyz, normal);
            ++reflectCount;
        }

        lastIntersection = stack[sp].hit + .001 * lastDirection;

    }
   //return vec4(vec2(surface*0.3, reflectCount*0.3), 0., 0.);

    if (hasHit) {
        stack[sp-1].color = directIllumination(stack[sp-1].localColor, stack[sp-1].hit, stack[sp-1].N, -stack[sp-1].dir, lightPosition-stack[sp-1].hit.xyz);
    }
    for (int i = sp-2; i >= 1; --i) {
        float cos_th = max(0.,dot(stack[i].N, -stack[i].dir));
        if (transparent && stack[i].h.hit_vptr != -1) {
            stack[i].color = directIllumination(stack[i].localColor, stack[i].hit, stack[i].N, -stack[i].dir, lightPosition-stack[i].hit.xyz)
                + stack[i+1].color;
        } else {
            stack[i].color = directIllumination(stack[i].localColor, stack[i].hit, stack[i].N, -stack[i].dir, lightPosition-stack[i].hit.xyz)
                            + vec4(fresnel(cos_th, vec2(eta3dReal.x, eta3dImag.x)),
                                   fresnel(cos_th, vec2(eta3dReal.y, eta3dImag.y)),
                                   fresnel(cos_th, vec2(eta3dReal.z, eta3dImag.z)),
                                   1.) * stack[i+1].color;
        }
    }
    if (sp-2 >= 0){
        float cos_th = max(0., dot(stack[0].N.xyz, -stack[0].dir.xyz));

        if (transparent && stack[0].h.hit_vptr != -1) {
            stack[0].color = directIllumination(vec4(0), stack[0].hit, stack[0].N, -stack[0].dir, lightPosition-stack[0].hit.xyz)
                + stack[1].color;
        } else {
            stack[0].color = directIllumination(stack[0].localColor, stack[0].hit, stack[0].N, -stack[0].dir, lightPosition-stack[0].hit.xyz)
                    + vec4(fresnel(cos_th, vec2(eta3dReal.x, eta3dImag.x)),
                           fresnel(cos_th, vec2(eta3dReal.y, eta3dImag.y)),
                           fresnel(cos_th, vec2(eta3dReal.z, eta3dImag.z)),
                           1.) * stack[1].color;
        }
    }
    return stack[0].color;


    // These are for TP1:
    hitinfo_t hl;
    vec4 hit;
    vec4 localColor;
    vec4 N;

    float specular_factor, LdN;

    if (firstIntersection(origin, dir, hl)) {
        getLocal(origin, dir, hl, localColor, hit, N);
        //return directIllumination(localColor, hit, N, -dir);
    }

    return vec4(0, 0, 0, 1);
}

layout (local_size_x = 8, local_size_y = 8) in;
void main(void) {

    // Convert local screen coordinates into world coordinates
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    vec2 perturb = .5-vec2(random(vec3(pix.xy, float(accumulationCount*0.135))),
                              random(vec3(pix.xy, float(accumulationCount*0.874))));


    vec4 pixVal = imageLoad(framebuffer, pix);

    if (resetAccumulation) {
        pixVal = vec4(0.);
    }

    float meansq = dot(pixVal.xyz, pixVal.xyz);
    float var = abs(pixVal.a - meansq);
    if ((accumulationCount > 100) && var<max(0.0001*meansq,0.001)) { // TODO: should be delayed ?
        //imageStore(framebuffer, pix, vec4(0.));
        return;
    }


    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }
    vec2 pos = (vec2(pix) + perturb) / (size - vec2(0.5, 0.5));
    // pos in [0,1]^2 Need it in [-1,1]^2:
    pos = 2 * pos - vec2(1., 1.);

    // Step 1: I need pixel coordinates.
    vec4 worldPos = vec4(pos.x, pos.y, 1.0, 1.0);
    worldPos = persp_inverse * worldPos;
    worldPos /= worldPos.w;
    worldPos.w = 0;
    worldPos = normalize(worldPos);
    // Step 2: ray direction:
    vec4 dir = normalize((mat_inverse * worldPos));
    vec4 eye = (mat_inverse * vec4(0, 0, 0, 1));
    vec4 color = trace(eye, dir);

    if (fastGammaCorrection) {
        color = min(pow(color, vec4(1./2.2)), 1.);
    }

    vec4 result = (pixVal*float(accumulationCount) + color)/float(accumulationCount+1);

    /*vec4 dist;
    bool hasHit = intersectGround(eye, dir, dist);
    if (hasHit) {
        result.g = dist.x*0.1;
    }

    hitinfo_t hit;
    hasHit = intersectBVH(eye, dir, hit);
    if (hasHit) {
        result.r = 100.;
    }

    hasHit = firstIntersection(eye, dir, hit);
    if (hasHit) {
        result.b = 100.;
    }*/

    imageStore(framebuffer, pix, result);

}
